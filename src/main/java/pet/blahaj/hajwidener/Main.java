package pet.blahaj.hajwidener;

import org.objectweb.asm.*;

import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

public class Main {
    public static void main(String[] args) throws IOException {
        String jarFilePath = "remapped.jar";

        List<String> results = processJar(jarFilePath);

        try (FileWriter writer = new FileWriter("haj.accesswidener")) {
            writer.write("accessWidener v1 named" + System.lineSeparator() + System.lineSeparator());
            writer.write("""
                    # Generated by blahaj.pet's hajwidener
                    #                   \s
                    # meow :3
                    #                            ╱|、
                    #                          (˚ˎ 。7 \s
                    #                           |、˜〵         \s
                    #                          じしˍ,)ノ
                    """ + System.lineSeparator());

            for (String result : results) {
                writer.write(result);
                writer.write(System.lineSeparator());
            }
        }
    }

    private static List<String> processJar(String jarFilePath) {
        List<String> results = new ArrayList<>();

        try (JarFile jarFile = new JarFile(jarFilePath)) {
            Enumeration<JarEntry> entries = jarFile.entries();

            while (entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                String entryName = entry.getName();

                if (entryName.endsWith(".class")) {
                    try (InputStream inputStream = jarFile.getInputStream(entry)) {
                        results.addAll(processClass(inputStream));
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        return results;
    }

    private static List<String> processClass(InputStream inputStream) throws IOException {
        ClassReader classReader = new ClassReader(inputStream);
        GeneratorVisitor classVisitor = new GeneratorVisitor();

        classReader.accept(classVisitor, ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
        return classVisitor.results;
    }

    private static class GeneratorVisitor extends ClassVisitor {
        String className = "";
        public List<String> results = new ArrayList<>();

        public GeneratorVisitor() {super(Opcodes.ASM9);}

        @Override
        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
            className = name;
            boolean isPublic = (access & Opcodes.ACC_PUBLIC) != 0;
            boolean isFinal = (access & Opcodes.ACC_FINAL) != 0;

            if (isFinal) results.add("extendable class " + className);
            if (!isPublic) results.add("accessible class " + className);
        }

        @Override
        public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
            boolean isPublic = (access & Opcodes.ACC_PUBLIC) != 0;
            boolean isFinal = (access & Opcodes.ACC_FINAL) != 0;

            if (isFinal) results.add("extendable method " + className + " " + name + " " + descriptor);
            if (!isPublic) results.add("accessible method " + className + " " + name + " " + descriptor);
            return null;
        }

        @Override
        public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {
            boolean isPublic = (access & Opcodes.ACC_PUBLIC) != 0;
            boolean isFinal = (access & Opcodes.ACC_FINAL) != 0;

            if (isFinal) results.add("mutable field " + className + " " + name + " " + descriptor);
            if (!isPublic) results.add("accessible field " + className + " " + name + " " + descriptor);
            return null;
        }
    }
}